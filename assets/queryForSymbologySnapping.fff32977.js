import{jE as C,f as q,be as z,bf as E,aR as D,t as I,mf as F,kp as G,mg as O,r as $,bL as P}from"./index.f0143bd6.js";import{a as k}from"./elevationInfoUtils.7e7fe510.js";async function H(t,p,f,u,o){const{elevationProvider:y,renderCoordsHelper:r,spatialReference:w}=t,{elevationInfo:m}=p,b=z(m,!0),R=await E(b,w,o);D(o);const c=[],l=new Set,g=new Set;for(const{objectId:i,points:e}of u){const n=f(i);if(I(n)){for(const a of e)c.push(a[2]);l.add(i);continue}n.isDraped&&g.add(i);const s=n.graphic.geometry;j.setFromElevationInfo(k(s,m)),j.updateFeatureExpressionInfoContext(R,n.graphic,p),h.spatialReference=t.spatialReference;for(const{x:a,y:d,z:S}of e)h.x=a,h.y=d,h.z=S!=null?S:0,F(h,y,j,r,v),c.push(v.z)}return{elevations:c,drapedObjectIds:g,failedObjectIds:l}}const j=new G,h=C(0,0,0,q.WGS84),v=new O;async function L(t,p,f){var i;if(I(t)||p.candidates.length===0)return x;const u=(i=t.graphics3DGraphicsByObjectID)!=null?i:t.graphics3DGraphics,o=[],y=[],{renderer:r}=t,w=$(r)&&"arcadeRequired"in r&&r.arcadeRequired?P():null,m=async(e,{graphic:n,graphics3DSymbol:s})=>{const a=await w,d=await t.getRenderingInfoAsync(n,r,a,{signal:f});return I(d)?[]:s.queryForSnapping(e,R,d,f)},{candidates:b,spatialReference:R}=p;for(let e=0;e<b.length;++e){const n=b[e],{objectId:s}=n,a=typeof s=="number"?u==null?void 0:u.get(s):void 0;if(I(a))continue;const{graphics3DSymbol:d}=a;d.symbologySnappingSupported&&(o.push(m(n,a)),y.push(e))}if(o.length===0)return x;const c=await Promise.all(o);D(f);const l=[],g=[];for(let e=0;e<c.length;++e){const n=c[e],s=y[e];for(const a of n)l.push(a),g.push(s)}return{candidates:l,sourceCandidateIndices:g}}const x={candidates:[],sourceCandidateIndices:[]};export{L as a,H as m};
