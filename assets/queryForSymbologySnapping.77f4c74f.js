import{jN as C,f as q,be as z,bf as F,aR as D,t as I,mo as G,ky as O,mp as $,r as E,bL as P}from"./index.766f8f29.js";import{a as k}from"./elevationInfoUtils.adb0b2db.js";async function H(t,p,f,u,o){const{elevationProvider:y,renderCoordsHelper:r,spatialReference:w}=t,{elevationInfo:m}=p,b=z(m,!0),R=await F(b,w,o);D(o);const c=[],l=new Set,h=new Set;for(const{objectId:i,points:e}of u){const n=f(i);if(I(n)){for(const a of e)c.push(a[2]);l.add(i);continue}n.isDraped&&h.add(i);const s=n.graphic.geometry;j.setFromElevationInfo(k(s,m)),j.updateFeatureExpressionInfoContext(R,n.graphic,p),g.spatialReference=t.spatialReference;for(const{x:a,y:d,z:S}of e)g.x=a,g.y=d,g.z=S!=null?S:0,G(g,y,j,r,v),c.push(v.z)}return{elevations:c,drapedObjectIds:h,failedObjectIds:l}}const j=new O,g=C(0,0,0,q.WGS84),v=new $;async function L(t,p,f){var i;if(I(t)||p.candidates.length===0)return x;const u=(i=t.graphics3DGraphicsByObjectID)!=null?i:t.graphics3DGraphics,o=[],y=[],{renderer:r}=t,w=E(r)&&"arcadeRequired"in r&&r.arcadeRequired?P():null,m=async(e,{graphic:n,graphics3DSymbol:s})=>{const a=await w,d=await t.getRenderingInfoAsync(n,r,a,{signal:f});return I(d)?[]:s.queryForSnapping(e,R,d,f)},{candidates:b,spatialReference:R}=p;for(let e=0;e<b.length;++e){const n=b[e],{objectId:s}=n,a=typeof s=="number"?u==null?void 0:u.get(s):void 0;if(I(a))continue;const{graphics3DSymbol:d}=a;d.symbologySnappingSupported&&(o.push(m(n,a)),y.push(e))}if(o.length===0)return x;const c=await Promise.all(o);D(f);const l=[],h=[];for(let e=0;e<c.length;++e){const n=c[e],s=y[e];for(const a of n)l.push(a),h.push(s)}return{candidates:l,sourceCandidateIndices:h}}const x={candidates:[],sourceCandidateIndices:[]};export{L as a,H as m};
