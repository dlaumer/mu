import{ah as P,cc as m,qQ as w,bM as K,L as n,qR as R,qS as f,qT as F,d$ as D,aG as M,i as U,qU as z,bJ as G,py as Y,r as $,qV as _,qW as g,qX as d}from"./index.f0b603e5.js";import{r as j}from"./fetchService.d8bf9569.js";import{o as v}from"./jsonContext.fc22b0d2.js";const B=P.getLogger("esri.layers.FeatureLayer"),c="Feature Service";function y(a,e){return`Layer (title: ${a.title}, id: ${a.id}) of type '${a.declaredClass}' ${e}`}function A(a,e){if(e.type!==c)throw new n("feature-layer:portal-item-wrong-type",y(a,`should have portal item of type "${c}"`))}async function N(a){if(await a.load(),R(a))throw new n("feature-layer:save",y(a,"using an in-memory source cannot be saved to a portal item"))}function C(a,e){var r;let t=((r=a.messages)!=null?r:[]).filter(({type:o})=>o==="error").map(({name:o,message:s,details:l})=>new n(o,s,l));if(e!=null&&e.ignoreUnsupported&&(t=t.filter(({name:o})=>o!=="layer:unsupported"&&o!=="symbol:unsupported"&&o!=="symbol-layer:unsupported"&&o!=="property:unsupported"&&o!=="url:unsupported")),t.length>0)throw new n("feature-layer:save","Failed to save feature layer due to unsupported or invalid content. See 'details.errors' for more detailed information",{errors:t})}async function h(a,e,t){"beforeSave"in a&&typeof a.beforeSave=="function"&&await a.beforeSave();const r=a.write({},e);return C(e,t),r}function O(a){const{layer:e,layerJSON:t}=a;return e.isTable?{layers:[],tables:[t]}:{layers:[t],tables:[]}}function b(a){f(a,d.JSAPI),a.typeKeywords&&(a.typeKeywords=a.typeKeywords.filter((e,t,r)=>r.indexOf(e)===t))}function H(a){const e=a.portalItem;if(!e)throw B.error("save: requires the portalItem property to be set"),new n("feature-layer:portal-item-not-set",y(a,"requires the portalItem property to be set"));if(!e.loaded)throw new n("feature-layer:portal-item-not-loaded",y(a,"cannot be saved to a portal item that does not exist or is inaccessible"));A(a,e)}async function T(a,e){var t;return/\/\d+\/?$/.test((t=a.url)!=null?t:"")?O(e[0]):Q(a,e)}async function Q(a,e){const{layer:{url:t,customParameters:r,apiKey:o}}=e[0];let s=await a.fetchData("json");s&&s.layers!=null&&s.tables!=null||(s=await V(s,{url:t!=null?t:"",customParameters:r,apiKey:o},e.map(l=>l.layer.layerId)));for(const l of e)x(l.layer,l.layerJSON,s);return s}async function V(a,e,t){var r,o;a||(a={}),(r=a).layers||(r.layers=[]),(o=a).tables||(o.tables=[]);const{url:s,customParameters:l,apiKey:i}=e,{serviceJSON:u,layersJSON:p}=await j(s,{customParameters:l,apiKey:i}),S=J(a.layers,u.layers,t),I=J(a.tables,u.tables,t);a.layers=S.itemResources,a.tables=I.itemResources;const E=[...S.added,...I.added],L=p?[...p.layers,...p.tables]:[];return await W(a,E,s,L),a}function J(a,e,t){const r=F(a,e,(s,l)=>s.id===l.id);a=a.filter(s=>!r.removed.some(l=>l.id===s.id));const o=r.added.map(({id:s})=>({id:s}));return o.forEach(({id:s})=>{a.push({id:s})}),{itemResources:a,added:o.filter(({id:s})=>!t.includes(s))}}async function W(a,e,t,r){const o=e.map(({id:s})=>new D({url:t,layerId:s,sourceJSON:r.find(({id:l})=>l===s)}));await M(o.map(s=>s.load())),o.forEach(s=>{const{layerId:l,loaded:i,defaultPopupTemplate:u}=s;!i||U(u)||x(s,{id:l,popupInfo:u.toJSON()},a)})}function x(a,e,t){a.isTable?q(t.tables,e):q(t.layers,e)}function q(a,e){if(!a)return;const t=a.findIndex(({id:r})=>r===e.id);t===-1?a.push(e):a[t]=e}function X(a){const{portalItem:e}=a;return z(a)&&!a.dynamicDataSource&&!!(e!=null&&e.loaded)&&e.type===c}async function k(a){if(!(a!=null&&a.length))throw new n("feature-layer-utils-saveall:missing-parameters","'layers' array should contain at least one feature layer");await Promise.all(a.map(r=>r.load()));for(const r of a)if(!X(r))throw new n("feature-layer-utils-saveall:invalid-parameters",`'layers' array should only contain layers or tables in a feature service loaded from 'Feature Service' item. ${y(r,"does not conform")}`,{layer:r});const e=a.map(r=>r.portalItem.id);if(new Set(e).size>1)throw new n("feature-layer-utils-saveall:invalid-parameters","All layers in the 'layers' array should be loaded from the same portal item");const t=a.map(r=>r.layerId);if(new Set(t).size!==t.length)throw new n("feature-layer-utils-saveall:invalid-parameters","'layers' array should contain only one instance each of layer or table in a feature service")}function Z(a,e){var s,l;var t,r;let o=G.from(e);return o.id&&(o=o.clone(),o.id=null),(s=(t=o).type)!=null||(t.type=c),(l=(r=o).portal)!=null||(r.portal=K.getDefault()),A(a,o),o}async function aa(a,e){const{url:t,layerId:r,title:o,fullExtent:s,isTable:l}=a,i=Y(t),u=$(i)&&i.serverType==="FeatureServer";e.url=u?t:`${t}/${r}`,e.title||(e.title=o),e.extent=null,!l&&$(s)&&(e.extent=await _(s)),g(e,d.METADATA),g(e,d.MULTI_LAYER),f(e,d.SINGLE_LAYER),l&&f(e,d.TABLE),b(e)}async function ea(a,e,t){var o;const r=a.portal;await(r==null?void 0:r.signIn()),await((o=r==null?void 0:r.user)==null?void 0:o.addItem({item:a,data:e,folder:t==null?void 0:t.folder}))}const na=m(ta);async function ta(a,e){await N(a),H(a);const t=a.portalItem,r=v(t),o=await h(a,r,e),s=await T(t,[{layer:a,layerJSON:o}]);return b(t),await t.update({data:s}),w(r),t}const ia=m(async(a,e)=>{await k(a);const t=a[0].portalItem,r=v(t),o=await Promise.all(a.map(l=>h(l,r,e))),s=await T(t,a.map((l,i)=>({layer:l,layerJSON:o[i]})));return b(t),await t.update({data:s}),await Promise.all(a.slice(1).map(l=>l.portalItem.reload())),w(r),t.clone()}),ua=m(ra);async function ra(a,e,t){await N(a);const r=Z(a,e),o=v(r),s=O({layer:a,layerJSON:await h(a,o,t)});return await aa(a,r),await ea(r,s,t),a.portalItem=r,w(o),r}export{na as save,ia as saveAll,ua as saveAs};
