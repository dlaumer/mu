import{lQ as Me,lR as Ne,bB as C,l7 as ye,gX as K,lS as xe,r as q,gU as Ce,lN as X,s as qe,aM as W,t as G,lT as Ge,lU as Y,lV as Pe,lW as k,g$ as _e,di as Oe,v as Ze,h0 as je,h1 as Be,bH as Ue,ki as Le,lX as Qe,hb as ne,_ as Fe,lY as H,lZ as Xe,l_ as Ye,l$ as ke,m0 as re,d as A,m1 as He,m2 as Je,m3 as oe,m4 as le,m5 as Ke,m6 as We,m7 as et,bL as tt}from"./index.c2b4fb6e.js";import{f as it}from"./WhereClause.fb4e6ae7.js";import{c as B,D as st,m as at,f as ue,d as ce,T as nt,y as rt,x as ot,z as lt,S as ut,M as ct,v as dt,p as ht}from"./utils.51e2592f.js";import{t as Ie}from"./json.5152e73f.js";const U=[0,0];function Se(a,t){if(!t)return null;if("x"in t){const e={x:0,y:0};return[e.x,e.y]=a(t.x,t.y,U),t.z!=null&&(e.z=t.z),t.m!=null&&(e.m=t.m),e}if("xmin"in t){const e={xmin:0,ymin:0,xmax:0,ymax:0};return[e.xmin,e.ymin]=a(t.xmin,t.ymin,U),[e.xmax,e.ymax]=a(t.xmax,t.ymax,U),t.hasZ&&(e.zmin=t.zmin,e.zmax=t.zmax,e.hasZ=!0),t.hasM&&(e.mmin=t.mmin,e.mmax=t.mmax,e.hasM=!0),e}return"rings"in t?{rings:de(t.rings,a),hasM:t.hasM,hasZ:t.hasZ}:"paths"in t?{paths:de(t.paths,a),hasM:t.hasM,hasZ:t.hasZ}:"points"in t?{points:Ve(t.points,a),hasM:t.hasM,hasZ:t.hasZ}:null}function de(a,t){const e=[];for(const i of a)e.push(Ve(i,t));return e}function Ve(a,t){const e=[];for(const i of a){const s=t(i[0],i[1],[0,0]);e.push(s),i.length>2&&s.push(i[2]),i.length>3&&s.push(i[3])}return e}async function Te(a,t){if(!a||!t)return;const e=Array.isArray(a)?a.map(i=>q(i.geometry)?i.geometry.spatialReference:null).filter(q):[a];await Ce(e.map(i=>({source:i,dest:t})))}const ve=Se.bind(null,Me),we=Se.bind(null,Ne);function Z(a,t,e,i){if(!a||(e||(e=t,t=a.spatialReference),!X(t)||!X(e)||C(t,e)))return a;if(ye(t,e)){const s=K(e)?ve(a):we(a);return s.spatialReference=e,s}return xe(Ie,[a],t,e,null,i)[0]}class ft{constructor(){this._jobs=[],this._timer=null,this._process=this._process.bind(this)}async push(t,e,i){if(!t||!t.length||!e||!i||C(e,i))return t;const s={geometries:t,inSpatialReference:e,outSpatialReference:i,resolve:null};return this._jobs.push(s),new Promise(n=>{s.resolve=n,this._timer===null&&(this._timer=setTimeout(this._process,10))})}_process(){this._timer=null;const t=this._jobs.shift();if(!t)return;const{geometries:e,inSpatialReference:i,outSpatialReference:s,resolve:n}=t;ye(i,s)?K(s)?n(e.map(ve)):n(e.map(we)):n(xe(Ie,e,i,s,null,null)),this._jobs.length>0&&(this._timer=setTimeout(this._process,10))}}const mt=new ft;function Dt(a,t,e){return mt.push(a,t,e)}const gt=new qe({esriSRUnit_Meter:"meters",esriSRUnit_Kilometer:"kilometers",esriSRUnit_Foot:"feet",esriSRUnit_StatuteMile:"miles",esriSRUnit_NauticalMile:"nautical-miles",esriSRUnit_USNauticalMile:"us-nautical-miles"}),he=Object.freeze({}),fe=new W,pt=new W,J=new W,b={esriGeometryPoint:H,esriGeometryPolyline:Xe,esriGeometryPolygon:Ye,esriGeometryMultipoint:ke};function me(a,t,e,i=a.hasZ,s=a.hasM){if(G(t))return null;const n=a.hasZ&&i,o=a.hasM&&s;if(e){const r=Y(J,t,a.hasZ,a.hasM,"esriGeometryPoint",e,i,s);return H(r,n,o)}return H(t,n,o)}function L(a,t,e,i,s,n,o=t,r=e){var d,m,h,f,x,S;const l=t&&o,u=e&&r,c=q(i)?"coords"in i?i:i.geometry:null;if(G(c))return null;if(s){let g=Ge(pt,c,t,e,a,s,o,r);return n&&(g=Y(J,g,l,u,a,n)),(m=(d=b[a])==null?void 0:d.call(b,g,l,u))!=null?m:null}if(n){const g=Y(J,c,t,e,a,n,o,r);return(f=(h=b[a])==null?void 0:h.call(b,g,l,u))!=null?f:null}return Pe(fe,c,t,e,o,r),(S=(x=b[a])==null?void 0:x.call(b,fe,l,u))!=null?S:null}async function zt(a,t,e){const{outFields:i,orderByFields:s,groupByFieldsForStatistics:n,outStatistics:o}=a;if(i)for(let r=0;r<i.length;r++)i[r]=i[r].trim();if(s)for(let r=0;r<s.length;r++)s[r]=s[r].trim();if(n)for(let r=0;r<n.length;r++)n[r]=n[r].trim();if(o)for(let r=0;r<o.length;r++)o[r].onStatisticField&&(o[r].onStatisticField=o[r].onStatisticField.trim());return a.geometry&&!a.outSR&&(a.outSR=a.geometry.spatialReference),yt(a,t,e)}async function yt(a,t,e){var n;if(!a)return null;let{where:i}=a;if(a.where=i=i&&i.trim(),(!i||/^1 *= *1$/.test(i)||t&&t===i)&&(a.where=null),!a.geometry)return a;let s=await _t(a);if(a.distance=0,a.units=null,a.spatialRel==="esriSpatialRelEnvelopeIntersects"){const{spatialReference:o}=a.geometry;s=k(s),s.spatialReference=o}if(s){await Te(s.spatialReference,e),s=xt(s,e);const o=(await Oe(Ze(s)))[0];if(G(o))throw he;const r="quantizationParameters"in a&&((n=a.quantizationParameters)==null?void 0:n.tolerance)||"maxAllowableOffset"in a&&a.maxAllowableOffset||0,l=r&&be(s,e)?{densificationStep:8*r}:void 0,u=o.toJSON(),c=await Z(u,u.spatialReference,e,l);if(!c)throw he;c.spatialReference=e,a.geometry=c}return a}function be(a,t){if(!a)return!1;const e=a.spatialReference;return(_e(a)||je(a)||Be(a))&&!C(e,t)&&!Ue(e,t)}function xt(a,t){const e=a.spatialReference;return be(a,t)&&_e(a)?{spatialReference:e,rings:[[[a.xmin,a.ymin],[a.xmin,a.ymax],[a.xmax,a.ymax],[a.xmax,a.ymin],[a.xmin,a.ymin]]]}:a}async function _t(a){const{distance:t,units:e}=a,i=a.geometry;if(t==null||"vertexAttributes"in i)return i;const s=i.spatialReference,n=e?gt.fromJSON(e):Le(s),o=s&&(Qe(s)||K(s))?i:await Te(s,ne).then(()=>Z(i,ne));return(await Ft())(o.spatialReference,o,t,n)}async function Ft(){return(await Fe(()=>import("./geometryEngineJSON.7ef32ff7.js"),["assets/geometryEngineJSON.7ef32ff7.js","assets/geometryEngineBase.871c2f6a.js","assets/geometryEngineJSON.7d40f72f.js","assets/json.5152e73f.js"])).geodesicBuffer}function Q(a){return a&&Re in a?JSON.parse(JSON.stringify(a,It)):a}const Re="_geVersion",It=(a,t)=>a!==Re?t:void 0;class St{constructor(t,e){this._cache=new re(t),this._invalidCache=new re(e)}get(t,e){const i=`${e.uid}:${t}`,s=this._cache.get(i);if(s)return s;if(this._invalidCache.get(i)!==void 0)return null;try{const n=it.create(t,e);return this._cache.put(i,n),n}catch{return this._invalidCache.put(i,null),null}}}const ee=new St(50,500),D="feature-store:unsupported-query",Ae=" as ",Vt=new Set(["esriFieldTypeOID","esriFieldTypeSmallInteger","esriFieldTypeInteger","esriFieldTypeSingle","esriFieldTypeDouble","esriFieldTypeLong","esriFieldTypeDate"]);function $t(a,t){if(!t)return!0;const e=ee.get(t,a);if(!e)throw new A(D,"invalid SQL expression",{where:t});if(!e.isStandardized)throw new A(D,"where clause is not standard",{where:t});return te(a,e.fieldNames,"where clause contains missing fields"),!0}function Et(a,t,e){if(!t)return!0;const i=ee.get(t,a);if(!i)throw new A(D,"invalid SQL expression",{having:t});if(!i.isAggregate)throw new A(D,"having does not contain a valid aggregate function",{having:t});const s=i.fieldNames;if(te(a,s,"having contains missing fields"),!i.getExpressions().every(n=>{var u;const{aggregateType:o,field:r}=n,l=(u=a.get(r))==null?void 0:u.name;return e.some(c=>{var f;const{onStatisticField:d,statisticType:m}=c;return((f=a.get(d))==null?void 0:f.name)===l&&m.toLowerCase().trim()===o})}))throw new A(D,"expressions in having should also exist in outStatistics",{having:t});return!0}function N(a,t){return a?ee.get(a,t):null}function te(a,t,e,i=!0){const s=[];for(const n of t)if(n!=="*"&&!a.has(n))if(i){const o=De(n);try{const r=N(o,a);if(!r)throw new A(D,"invalid SQL expression",{where:o});if(!r.isStandardized)throw new A(D,"expression is not standard",{clause:r});te(a,r.fieldNames,"expression contains missing fields")}catch(r){const l=r&&r.details;if(l&&(l.clause||l.where))throw r;l&&l.missingFields?s.push(...l.missingFields):s.push(n)}}else s.push(n);if(s.length)throw new A(D,e,{missingFields:s})}function De(a){return a.split(Ae)[0]}function Tt(a){return a.split(Ae)[1]}function Mt(a,t){const e=t.get(a);return!!e&&!Vt.has(e.type)}class O{constructor(t,e,i){var n;this._fieldDataCache=new Map,this._returnDistinctMap=new Map,this.returnDistinctValues=(n=t.returnDistinctValues)!=null?n:!1,this.fieldsIndex=i,this.featureAdapter=e;const s=t.outFields;if(s&&!s.includes("*")){this.outFields=s;let o=0;for(const r of s){const l=De(r),u=this.fieldsIndex.get(l),c=u?null:N(l,i),d=u?u.name:Tt(r)||"FIELD_EXP_"+o++;this._fieldDataCache.set(r,{alias:d,clause:c})}}}countDistinctValues(t){return this.returnDistinctValues?(t.forEach(e=>this.getAttributes(e)),this._returnDistinctMap.size):t.length}getAttributes(t){const e=this._processAttributesForOutFields(t);return this._processAttributesForDistinctValues(e)}getFieldValue(t,e,i){var o;const s=i?i.name:e;let n=null;return this._fieldDataCache.has(s)?n=(o=this._fieldDataCache.get(s))==null?void 0:o.clause:i||(n=N(e,this.fieldsIndex),this._fieldDataCache.set(s,{alias:s,clause:n})),i?this.featureAdapter.getAttribute(t,s):n==null?void 0:n.calculateValue(t,this.featureAdapter)}getDataValue(t,e){const i=e.normalizationType,s=e.normalizationTotal;let n=e.field&&this.getFieldValue(t,e.field,this.fieldsIndex.get(e.field));if(e.field2&&(n=`${B(n)}${e.fieldDelimiter}${B(this.getFieldValue(t,e.field2,this.fieldsIndex.get(e.field2)))}`,e.field3&&(n=`${n}${e.fieldDelimiter}${B(this.getFieldValue(t,e.field3,this.fieldsIndex.get(e.field3)))}`)),i&&Number.isFinite(n)){const o=i==="field"&&e.normalizationField?this.getFieldValue(t,e.normalizationField,this.fieldsIndex.get(e.normalizationField)):null;n=st(n,i,o,s)}return n}getExpressionValue(t,e,i,s){const n={attributes:this.featureAdapter.getAttributes(t),layer:{fields:this.fieldsIndex.fields}},o=s.createExecContext(n,i);return s.executeFunction(e,o)}getExpressionValues(t,e,i,s){const n={fields:this.fieldsIndex.fields};return t.map(o=>{const r={attributes:this.featureAdapter.getAttributes(o),layer:n},l=s.createExecContext(r,i);return s.executeFunction(e,l)})}validateItem(t,e){var i,s,n;return this._fieldDataCache.has(e)||this._fieldDataCache.set(e,{alias:e,clause:N(e,this.fieldsIndex)}),(n=(s=(i=this._fieldDataCache.get(e))==null?void 0:i.clause)==null?void 0:s.testFeature(t,this.featureAdapter))!=null?n:!1}validateItems(t,e){var i,s,n;return this._fieldDataCache.has(e)||this._fieldDataCache.set(e,{alias:e,clause:N(e,this.fieldsIndex)}),(n=(s=(i=this._fieldDataCache.get(e))==null?void 0:i.clause)==null?void 0:s.testSet(t,this.featureAdapter))!=null?n:!1}_processAttributesForOutFields(t){const e=this.outFields;if(!e||!e.length)return this.featureAdapter.getAttributes(t);const i={};for(const s of e){const{alias:n,clause:o}=this._fieldDataCache.get(s);i[n]=o?o.calculateValue(t,this.featureAdapter):this.featureAdapter.getAttribute(t,n)}return i}_processAttributesForDistinctValues(t){if(G(t)||!this.returnDistinctValues)return t;const e=this.outFields,i=[];if(e)for(const o of e){const{alias:r}=this._fieldDataCache.get(o);i.push(t[r])}else for(const o in t)i.push(t[o]);const s=`${(e||["*"]).join(",")}=${i.join(",")}`;let n=this._returnDistinctMap.get(s)||0;return this._returnDistinctMap.set(s,++n),n>1?null:t}}class Nt{constructor(t,e,i){this.items=t,this.query=e,this.geometryType=i.geometryType,this.hasM=i.hasM,this.hasZ=i.hasZ,this.fieldsIndex=i.fieldsIndex,this.objectIdField=i.objectIdField,this.spatialReference=i.spatialReference,this.featureAdapter=i.featureAdapter}get size(){return this.items.length}createQueryResponseForCount(){const t=new O(this.query,this.featureAdapter,this.fieldsIndex);if(!this.query.outStatistics)return t.countDistinctValues(this.items);const{groupByFieldsForStatistics:e,having:i,outStatistics:s}=this.query;if(!(e==null?void 0:e.length))return 1;const o=new Map,r=new Map,l=new Set;for(const u of s){const{statisticType:c}=u,d=c!=="exceedslimit"?u.onStatisticField:void 0;if(!r.has(d)){const h=[];for(const f of e){const x=this._getAttributeValues(t,f,o);h.push(x)}r.set(d,this._calculateUniqueValues(h,t.returnDistinctValues))}const m=r.get(d);for(const h in m){const{data:f,items:x}=m[h],S=f.join(",");i&&!t.validateItems(x,i)||l.add(S)}}return l.size}async createQueryResponse(){let t;if(this.query.outStatistics?t=this.query.outStatistics.some(e=>e.statisticType==="exceedslimit")?this._createExceedsLimitQueryResponse(this.query):await this._createStatisticsQueryResponse(this.query):t=this._createFeatureQueryResponse(this.query),this.query.returnQueryGeometry){const e=this.query.geometry;X(this.query.outSR)&&!C(e.spatialReference,this.query.outSR)?t.queryGeometry=Q({spatialReference:this.query.outSR,...Z(e,e.spatialReference,this.query.outSR)}):t.queryGeometry=Q({spatialReference:this.query.outSR,...e})}return t}createSnappingResponse(t,e){const i=this.featureAdapter,s=ge(this.hasZ,this.hasM),{point:n,mode:o}=t,r=typeof t.distance=="number"?t.distance:t.distance.x,l=typeof t.distance=="number"?t.distance:t.distance.y,u={candidates:[]},c=this.geometryType==="esriGeometryPolygon",d=this._getPointCreator(o,this.spatialReference,e),m=new pe(null,0),h=new pe(null,0),f={x:0,y:0,z:0};for(const x of this.items){const S=i.getGeometry(x);if(G(S))continue;const{coords:g,lengths:V}=S;if(m.coords=g,h.coords=g,t.types&j.EDGE){let F=0;for(let I=0;I<V.length;I++){const _=V[I];for(let p=0;p<_;p++,F+=s){const y=m;if(y.coordsIndex=F,p!==_-1){const T=h;T.coordsIndex=F+s;const E=f;vt(f,n,y,T);const v=(n.x-E.x)/r,w=(n.y-E.y)/l,z=v*v+w*w;z<=1&&u.candidates.push(He(i.getObjectId(x),d(E),Math.sqrt(z),d(y),d(T)))}}}}if(t.types&j.VERTEX){const F=c?g.length-s:g.length;for(let I=0;I<F;I+=s){const _=m;_.coordsIndex=I;const p=(n.x-_.x)/r,y=(n.y-_.y)/l,T=p*p+y*y;T<=1&&u.candidates.push(Je(i.getObjectId(x),d(_),Math.sqrt(T)))}}}return u.candidates.sort((x,S)=>x.distance-S.distance),u}_getPointCreator(t,e,i){const s=q(i)&&!C(e,i)?r=>Z(r,e,i):r=>r,{hasZ:n}=this,o=0;return t==="3d"?n?({x:r,y:l,z:u})=>s({x:r,y:l,z:u}):({x:r,y:l})=>s({x:r,y:l,z:o}):({x:r,y:l})=>s({x:r,y:l})}async createSummaryStatisticsResponse(t){const{field:e,valueExpression:i,normalizationField:s,normalizationType:n,normalizationTotal:o,minValue:r,maxValue:l,scale:u}=t,c=this.fieldsIndex.isDateField(e),d=await this._getDataValues({field:e,valueExpression:i,normalizationField:s,normalizationType:n,normalizationTotal:o,scale:u}),m=at({normalizationType:n,normalizationField:s,minValue:r,maxValue:l}),h=this.fieldsIndex.get(e),f={value:.5,fieldType:h==null?void 0:h.type},x=oe(h)?ue({values:d,supportsNullCount:m,percentileParams:f}):ce({values:d,minValue:r,maxValue:l,useSampleStdDev:!n,supportsNullCount:m,percentileParams:f});return nt(x,c)}async createUniqueValuesResponse(t){const{field:e,valueExpression:i,domains:s,returnAllCodedValues:n,scale:o}=t,r=await this._getDataValues({field:e,field2:t.field2,field3:t.field3,fieldDelimiter:t.fieldDelimiter,valueExpression:i,scale:o}),l=rt(r);return ot(l,s,n,t.fieldDelimiter)}async createClassBreaksResponse(t){const{field:e,valueExpression:i,normalizationField:s,normalizationType:n,normalizationTotal:o,classificationMethod:r,standardDeviationInterval:l,minValue:u,maxValue:c,numClasses:d,scale:m}=t,h=await this._getDataValues({field:e,valueExpression:i,normalizationField:s,normalizationType:n,normalizationTotal:o,scale:m}),f=lt(h,{field:e,normalizationField:s,normalizationType:n,normalizationTotal:o,classificationMethod:r,standardDeviationInterval:l,minValue:u,maxValue:c,numClasses:d});return ut(f,r)}async createHistogramResponse(t){const{field:e,valueExpression:i,normalizationField:s,normalizationType:n,normalizationTotal:o,classificationMethod:r,standardDeviationInterval:l,minValue:u,maxValue:c,numBins:d,scale:m}=t,h=await this._getDataValues({field:e,valueExpression:i,normalizationField:s,normalizationType:n,normalizationTotal:o,scale:m});return ct(h,{field:e,normalizationField:s,normalizationType:n,normalizationTotal:o,classificationMethod:r,standardDeviationInterval:l,minValue:u,maxValue:c,numBins:d})}_sortFeatures(t,e,i){if(t.length>1&&e&&e.length)for(const s of e.reverse()){const n=s.split(" "),o=n[0],r=this.fieldsIndex.get(o),l=!!n[1]&&n[1].toLowerCase()==="desc",u=dt(r==null?void 0:r.type,l);t.sort((c,d)=>{const m=i(c,o,r),h=i(d,o,r);return u(m,h)})}}_createFeatureQueryResponse(t){const e=this.items,{geometryType:i,hasM:s,hasZ:n,objectIdField:o,spatialReference:r}=this,{outFields:l,outSR:u,quantizationParameters:c,resultRecordCount:d,resultOffset:m,returnZ:h,returnM:f}=t,x=d!=null&&e.length>(m||0)+d,S=l&&(l.includes("*")?[...this.fieldsIndex.fields]:l.map(g=>this.fieldsIndex.get(g)));return{exceededTransferLimit:x,features:this._createFeatures(t,e),fields:S,geometryType:i,hasM:s&&f,hasZ:n&&h,objectIdFieldName:o,spatialReference:Q(u||r),transform:c&&le(c)||null}}_createFeatures(t,e){var _;const i=new O(t,this.featureAdapter,this.fieldsIndex),{hasM:s,hasZ:n}=this,{orderByFields:o,quantizationParameters:r,returnGeometry:l,returnCentroid:u,maxAllowableOffset:c,resultOffset:d,resultRecordCount:m,returnZ:h=!1,returnM:f=!1}=t,x=n&&h,S=s&&f;let g=[],V=0;const F=[...e];if(this._sortFeatures(F,o,(p,y,T)=>i.getFieldValue(p,y,T)),l||u){const p=(_=le(r))!=null?_:void 0;if(l&&!u)for(const y of F)g[V++]={attributes:i.getAttributes(y),geometry:L(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(y),c,p,x,S)};else if(!l&&u)for(const y of F)g[V++]={attributes:i.getAttributes(y),centroid:me(this,this.featureAdapter.getCentroid(y,this),p)};else for(const y of F)g[V++]={attributes:i.getAttributes(y),centroid:me(this,this.featureAdapter.getCentroid(y,this),p),geometry:L(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(y),c,p,x,S)}}else for(const p of F){const y=i.getAttributes(p);y&&(g[V++]={attributes:y})}const I=d||0;if(m!=null){const p=I+m;g=g.slice(I,Math.min(g.length,p))}return g}_createExceedsLimitQueryResponse(t){var o;let e=!1,i=Number.POSITIVE_INFINITY,s=Number.POSITIVE_INFINITY,n=Number.POSITIVE_INFINITY;for(const r of(o=t.outStatistics)!=null?o:[])if(r.statisticType==="exceedslimit"){i=r.maxPointCount!=null?r.maxPointCount:Number.POSITIVE_INFINITY,s=r.maxRecordCount!=null?r.maxRecordCount:Number.POSITIVE_INFINITY,n=r.maxVertexCount!=null?r.maxVertexCount:Number.POSITIVE_INFINITY;break}if(this.geometryType==="esriGeometryPoint")e=this.items.length>i;else if(this.items.length>s)e=!0;else{const r=ge(this.hasZ,this.hasM),l=this.featureAdapter;e=this.items.reduce((u,c)=>{const d=l.getGeometry(c);return u+(q(d)&&d.coords.length||0)},0)/r>n}return{fields:[{name:"exceedslimit",type:"esriFieldTypeInteger",alias:"exceedslimit",sqlType:"sqlTypeInteger",domain:null,defaultValue:null}],features:[{attributes:{exceedslimit:Number(e)}}]}}async _createStatisticsQueryResponse(t){const e={attributes:{}},i=[],s=new Map,n=new Map,o=new Map,r=new Map,l=new O(t,this.featureAdapter,this.fieldsIndex),u=t.outStatistics,{groupByFieldsForStatistics:c,having:d,orderByFields:m}=t,h=c&&c.length,f=!!h,x=f?c[0]:null,S=f&&!this.fieldsIndex.get(x);for(const V of u!=null?u:[]){const{outStatisticFieldName:F,statisticType:I}=V,_=V,p=I!=="exceedslimit"?V.onStatisticField:void 0,y=I==="percentile_disc"||I==="percentile_cont",T=I==="EnvelopeAggregate"||I==="CentroidAggregate"||I==="ConvexHullAggregate",E=f&&h===1&&(p===x||S)&&I==="count";if(f){if(!o.has(p)){const w=[];for(const z of c){const P=this._getAttributeValues(l,z,s);w.push(P)}o.set(p,this._calculateUniqueValues(w,!T&&l.returnDistinctValues))}const v=o.get(p);for(const w in v){const{count:z,data:P,items:ie,itemPositions:ze}=v[w],se=P.join(",");if(!d||l.validateItems(ie,d)){const $=r.get(se)||{attributes:{}};if(T){$.aggregateGeometries||($.aggregateGeometries={});const{aggregateGeometries:R,outStatisticFieldName:M}=await this._getAggregateGeometry(_,ie);$.aggregateGeometries[M]=R}else{let R=null;if(E)R=z;else{const M=this._getAttributeValues(l,p,s),ae=ze.map(Ee=>M[Ee]);R=y&&"statisticParameters"in _?this._getPercentileValue(_,ae):this._getStatisticValue(_,ae,null,l.returnDistinctValues)}$.attributes[F]=R}let $e=0;c.forEach((R,M)=>$.attributes[this.fieldsIndex.get(R)?R:"EXPR_"+ ++$e]=P[M]),r.set(se,$)}}}else if(T){e.aggregateGeometries||(e.aggregateGeometries={});const{aggregateGeometries:v,outStatisticFieldName:w}=await this._getAggregateGeometry(_,this.items);e.aggregateGeometries[w]=v}else{const v=this._getAttributeValues(l,p,s);e.attributes[F]=y&&"statisticParameters"in _?this._getPercentileValue(_,v):this._getStatisticValue(_,v,n,l.returnDistinctValues)}i.push({name:F,alias:F,type:"esriFieldTypeDouble"})}const g=f?Array.from(r.values()):[e];return this._sortFeatures(g,m,(V,F)=>V.attributes[F]),{fields:i,features:g}}async _getAggregateGeometry(t,e){const i=await Fe(()=>import("./geometryEngineJSON.7ef32ff7.js"),["assets/geometryEngineJSON.7ef32ff7.js","assets/geometryEngineBase.871c2f6a.js","assets/geometryEngineJSON.7d40f72f.js","assets/json.5152e73f.js"]),{statisticType:s,outStatisticFieldName:n}=t,{featureAdapter:o,spatialReference:r,geometryType:l,hasZ:u,hasM:c}=this,d=e.map(f=>L(l,u,c,o.getGeometry(f))),m=i.convexHull(r,d,!0)[0],h={aggregateGeometries:null,outStatisticFieldName:null};if(s==="EnvelopeAggregate"){const f=m?Ke(m):k(i.union(r,d));h.aggregateGeometries={...f,spatialReference:r},h.outStatisticFieldName=n||"extent"}else if(s==="CentroidAggregate"){const f=m?We(m):et(k(i.union(r,d)));h.aggregateGeometries={x:f[0],y:f[1],spatialReference:r},h.outStatisticFieldName=n||"centroid"}else s==="ConvexHullAggregate"&&(h.aggregateGeometries=m,h.outStatisticFieldName=n||"convexHull");return h}_getStatisticValue(t,e,i,s){const{onStatisticField:n,statisticType:o}=t;let r=null;return r=i!=null&&i.has(n)?i.get(n):oe(this.fieldsIndex.get(n))?ue({values:e,returnDistinct:s}):ce({values:s?[...new Set(e)]:e,minValue:null,maxValue:null,useSampleStdDev:!0}),i&&i.set(n,r),r[o==="var"?"variance":o]}_getPercentileValue(t,e){const{onStatisticField:i,statisticParameters:s,statisticType:n}=t,{value:o,orderBy:r}=s,l=this.fieldsIndex.get(i);return ht(e,{value:o,orderBy:r,fieldType:l==null?void 0:l.type,isDiscrete:n==="percentile_disc"})}_getAttributeValues(t,e,i){if(i.has(e))return i.get(e);const s=this.fieldsIndex.get(e),n=this.items.map(o=>t.getFieldValue(o,e,s));return i.set(e,n),n}_getAttributeDataValues(t,e){return this.items.map(i=>t.getDataValue(i,{field:e.field,field2:e.field2,field3:e.field3,fieldDelimiter:e.fieldDelimiter,normalizationField:e.normalizationField,normalizationType:e.normalizationType,normalizationTotal:e.normalizationTotal}))}async _getAttributeExpressionValues(t,e,i){const{arcadeUtils:s}=await tt(),n=s.createFunction(e),o=i&&s.getViewInfo(i);return t.getExpressionValues(this.items,n,o,s)}_calculateUniqueValues(t,e){const i={},s=this.items,n=s.length;for(let o=0;o<n;o++){const r=s[o],l=[];for(const c of t)l.push(c[o]);const u=l.join(",");i[u]==null?i[u]={count:1,data:l,items:[r],itemPositions:[o]}:(e||i[u].count++,i[u].items.push(r),i[u].itemPositions.push(o))}return i}async _getDataValues(t){const e=new O(this.query,this.featureAdapter,this.fieldsIndex),{valueExpression:i,field:s,normalizationField:n,normalizationType:o,normalizationTotal:r,scale:l}=t,u=i?{viewingMode:"map",scale:l,spatialReference:this.query.outSR||this.spatialReference}:null;return i?this._getAttributeExpressionValues(e,i,u):this._getAttributeDataValues(e,{field:s,field2:t.field2,field3:t.field3,fieldDelimiter:t.fieldDelimiter,normalizationField:n,normalizationType:o,normalizationTotal:r})}}function vt(a,t,e,i){const s=i.x-e.x,n=i.y-e.y,o=s*s+n*n,r=(t.x-e.x)*s+(t.y-e.y)*n,l=Math.min(1,Math.max(0,r/o));a.x=e.x+s*l,a.y=e.y+n*l}function ge(a,t){return a?t?4:3:t?3:2}var j;(function(a){a[a.NONE=0]="NONE",a[a.EDGE=1]="EDGE",a[a.VERTEX=2]="VERTEX"})(j||(j={}));class pe{constructor(t,e){this.coords=t,this.coordsIndex=e}get x(){return this.coords[this.coordsIndex]}get y(){return this.coords[this.coordsIndex+1]}get z(){return this.coords[this.coordsIndex+2]}}export{Nt as A,j as D,Q as E,he as F,yt as J,Dt as M,Et as a,Mt as b,te as c,Te as f,Z as g,N as l,$t as o,L as v,zt as z};
