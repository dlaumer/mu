import{ef as z,c1 as C,ay as G,az as q,a7 as D,i as b,hG as F,fc as O,hH as $,r as E,b4 as H}from"./index.f0b603e5.js";import{a as P}from"./elevationInfoUtils.1b829c91.js";async function M(s,p,f,u,o){const{elevationProvider:y,renderCoordsHelper:r,spatialReference:w}=s,{elevationInfo:m}=p,I=G(m,!0),S=await q(I,w,o);D(o);const c=[],l=new Set,h=new Set;for(const{objectId:i,points:e}of u){const n=f(i);if(b(n)){for(const a of e)c.push(a[2]);l.add(i);continue}n.isDraped&&h.add(i);const t=n.graphic.geometry;R.setFromElevationInfo(P(t,m)),R.updateFeatureExpressionInfoContext(S,n.graphic,p),g.spatialReference=s.spatialReference;for(const{x:a,y:d,z:v}of e)g.x=a,g.y=d,g.z=v!=null?v:0,F(g,y,R,r,j),c.push(j.z)}return{elevations:c,drapedObjectIds:h,failedObjectIds:l}}const R=new O,g=z(0,0,0,C.WGS84),j=new $;async function T(s,p,f){var i;if(b(s)||p.candidates.length===0)return x;const u=(i=s.graphics3DGraphicsByObjectID)!=null?i:s.graphics3DGraphics,o=[],y=[],{renderer:r}=s,w=E(r)&&"arcadeRequired"in r&&r.arcadeRequired?H():null,m=async(e,{graphic:n,graphics3DSymbol:t})=>{const a=await w,d=await s.getRenderingInfoAsync(n,r,a,{signal:f});return b(d)?[]:t.queryForSnapping(e,S,d,f)},{candidates:I,spatialReference:S}=p;for(let e=0;e<I.length;++e){const n=I[e],{objectId:t}=n,a=typeof t=="number"?u==null?void 0:u.get(t):void 0;if(b(a))continue;const{graphics3DSymbol:d}=a;d.symbologySnappingSupported&&(o.push(m(n,a)),y.push(e))}if(o.length===0)return x;const c=await Promise.all(o);D(f);const l=[],h=[];for(let e=0;e<c.length;++e){const n=c[e],t=y[e];for(const a of n)l.push(a),h.push(t)}return{candidates:l,sourceCandidateIndices:h}}const x={candidates:[],sourceCandidateIndices:[]};export{T as a,M as m};
