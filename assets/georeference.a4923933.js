import{e as u,y as g,b as q,c3 as I,an as b,na as R,kn as G,nb as Y,nc as V,nd as C,ne as H,dS as L,dy as m,dU as E,nf as f,dH as j,dx as P,eA as K,ng as A,bb as U,nh as D,ni as J,nj as W,aS as Z,r as w,kT as Q,nk as X,kh as x,nl as nn,kV as tn,nm as rn,nn as k,i as h,no as $,lK as y,np as en,nq as an,cf as on,ae as sn,jK as ln,dT as cn,nr as pn,ns as un,nt as gn,nu as hn,nv as fn,nw as yn}from"./index.f0b603e5.js";var T;let p=T=class extends I{constructor(n){super(n),this.origin=b(),this.translation=b(),this.rotation=R(),this.scale=G(1,1,1),this.geographic=!0}get localMatrix(){const n=m();return Y(N,C(this.rotation),V(this.rotation)),H(n,N,this.translation,this.scale),n}get localMatrixInverse(){return L(m(),this.localMatrix)}applyLocal(n,t){return E(t,n,this.localMatrix)}applyLocalInverse(n,t){return E(t,n,this.localMatrixInverse)}project(n,t){const r=new Float64Array(n.length),e=f.fromTypedArray(r),a=f.fromTypedArray(n);if(this.geographic){const s=j(t),c=m();return P(t,this.origin,c,s),K(c,c,this.localMatrix),A(e,a,c),U(r,s,0,r,t,0,r.length/3),r}const{localMatrix:o,origin:i}=this;D(o,J)?W(e,a):A(e,a,o);for(let s=0;s<r.length;s+=3)r[s+0]+=i[0],r[s+1]+=i[1],r[s+2]+=i[2];return r}getOriginPoint(n){const[t,r,e]=this.origin;return new Z({x:t,y:r,z:e,spatialReference:n})}equals(n){return w(n)&&this.geographic===n.geographic&&Q(this.origin,n.origin)&&X(this.localMatrix,n.localMatrix)}clone(){const n={origin:x(this.origin),translation:x(this.translation),rotation:R(this.rotation),scale:x(this.scale),geographic:this.geographic};return new T(n)}};u([g({type:[Number],nonNullable:!0,json:{write:!0}})],p.prototype,"origin",void 0),u([g({type:[Number],nonNullable:!0,json:{write:!0}})],p.prototype,"translation",void 0),u([g({type:[Number],nonNullable:!0,json:{write:!0}})],p.prototype,"rotation",void 0),u([g({type:[Number],nonNullable:!0,json:{write:!0}})],p.prototype,"scale",void 0),u([g({type:Boolean,nonNullable:!0,json:{write:!0}})],p.prototype,"geographic",void 0),u([g()],p.prototype,"localMatrix",null),u([g()],p.prototype,"localMatrixInverse",null),p=T=u([q("esri.geometry.support.MeshTransform")],p);const N=nn(),mn=p;function M(n,t){var r;return n.isGeographic||n.isWebMercator&&((r=t==null?void 0:t.geographic)!=null?r:!0)}function B(n,t,r){return M(t.spatialReference,r)?dn(n,t,r):$n(n,t,r)}function An(n,t,r){const{position:e,normal:a,tangent:o}=n;if(h(t))return{position:e,normal:a,tangent:o};const i=t.localMatrix;return B({position:hn(e,new Float64Array(e.length),i),normal:w(a)?fn(a,new Float32Array(a.length),i):null,tangent:w(o)?yn(o,new Float32Array(o.length),i):null},t.getOriginPoint(r),{geographic:t.geographic})}function zn(n,t,r){var e;if(r!=null&&r.useTransform){const{position:a,normal:o,tangent:i}=n;return{vertexAttributes:{position:a,normal:o,tangent:i},transform:new mn({origin:[t.x,t.y,(e=t.z)!=null?e:0],geographic:M(t.spatialReference,r)})}}return{vertexAttributes:B(n,t,r),transform:null}}function z(n,t,r){return M(t.spatialReference,r)?vn(n,t,r):_(n,t,r)}function Ln(n,t,r,e){if(h(t))return z(n,r,e);const a=An(n,t,r.spatialReference);return r.equals(t.getOriginPoint(r.spatialReference))?_(a,r,e):z(a,r,e)}function $n(n,t,r){const e=new Float64Array(n.position.length),a=n.position,o=t.x,i=t.y,s=t.z||0,{horizontal:c,vertical:d}=F(r?r.unit:null,t.spatialReference);for(let l=0;l<a.length;l+=3)e[l+0]=a[l+0]*c+o,e[l+1]=a[l+1]*c+i,e[l+2]=a[l+2]*d+s;return{position:e,normal:n.normal,tangent:n.tangent}}function dn(n,t,r){const e=t.spatialReference,a=O(t,r,v),o=new Float64Array(n.position.length),i=xn(n.position,a,e,o),s=k(S,a);return{position:i,normal:wn(i,o,n.normal,s,e),tangent:Tn(i,o,n.tangent,s,e)}}function xn(n,t,r,e){A(f.fromTypedArray(e),f.fromTypedArray(n),t);const a=new Float64Array(n.length);return rn(e,a,r)}function wn(n,t,r,e,a){if(h(r))return null;const o=new Float32Array(r.length);return $(y.fromTypedArray(o),y.fromTypedArray(r),e),en(o,n,t,a,o),o}function Tn(n,t,r,e,a){if(h(r))return null;const o=new Float32Array(r.length);$(y.fromTypedArray(o,4*Float32Array.BYTES_PER_ELEMENT),y.fromTypedArray(r,4*Float32Array.BYTES_PER_ELEMENT),e);for(let i=3;i<o.length;i+=4)o[i]=r[i];return an(o,n,t,a,o),o}function _(n,t,r){const e=new Float64Array(n.position.length),a=n.position,o=t.x,i=t.y,s=t.z||0,{horizontal:c,vertical:d}=F(r?r.unit:null,t.spatialReference);for(let l=0;l<a.length;l+=3)e[l+0]=(a[l+0]-o)/c,e[l+1]=(a[l+1]-i)/c,e[l+2]=(a[l+2]-s)/d;return{position:e,normal:n.normal,tangent:n.tangent}}function vn(n,t,r){const e=t.spatialReference;O(t,r,v);const a=L(Rn,v),o=new Float64Array(n.position.length),i=Mn(n.position,e,a,o),s=k(S,a);return{position:i,normal:Fn(n.normal,n.position,o,e,s),tangent:bn(n.tangent,n.position,o,e,s)}}function O(n,t,r){P(n.spatialReference,[n.x,n.y,n.z||0],r,j(n.spatialReference));const{horizontal:e,vertical:a}=F(t?t.unit:null,n.spatialReference);return tn(r,r,[e,e,a]),r}function Mn(n,t,r,e){const a=pn(n,t,e),o=f.fromTypedArray(a),i=new Float64Array(a.length),s=f.fromTypedArray(i);return A(s,o,r),i}function Fn(n,t,r,e,a){if(h(n))return null;const o=un(n,t,r,e,new Float32Array(n.length)),i=y.fromTypedArray(o);return $(i,i,a),o}function bn(n,t,r,e,a){if(h(n))return null;const o=gn(n,t,r,e,new Float32Array(n.length)),i=y.fromTypedArray(o,4*Float32Array.BYTES_PER_ELEMENT);return $(i,i,a),o}function F(n,t){if(h(n))return En;const r=t.isGeographic?1:on(t),e=t.isGeographic?1:sn(t),a=ln(1,n,"meters");return{horizontal:a*r,vertical:a*e}}const v=m(),Rn=m(),S=cn(),En={horizontal:1,vertical:1};export{mn as L,Ln as M,zn as _,z as b,An as k,M as r,B as x};
